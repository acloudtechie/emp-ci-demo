package net.micropact.aea.du.page.mismatchedColumnTypes;

import java.util.LinkedList;
import java.util.List;

import com.entellitrak.ApplicationException;
import com.entellitrak.PageExecutionContext;
import com.entellitrak.page.PageController;
import com.entellitrak.page.Response;
import com.entellitrak.page.TextResponse;

import net.micropact.aea.core.cache.AeaCoreConfiguration;
import net.micropact.aea.utility.Utility;

/**
 * This class attempts to find column type differences between the entellitrak meta-data tables and the actual
 * database columns.
 * It not only looks at the actual data types, but also accounts for column lengths and precisions.
 * Currently this page makes no attempt to assist the user with correcting the problem,
 * it only serves to point out where it believes there is one.
 * @author zmiller
 */
public class MismatchedColumnTypesController implements PageController {

    @Override
    public Response execute(final PageExecutionContext etk)
            throws ApplicationException {
            final TextResponse response = etk.createTextResponse();

            // TODO: Restructure query to accept a list containing just null
            // We copy the list so that when we add the excluded column, it doesn't modify the version in the cache
            final List<String> excludedColumns =
                    new LinkedList<>(AeaCoreConfiguration.getDuMismatchColumnExclusions(etk));
            excludedColumns.add("  Invalid Table Name To Make List Non-Empty  ");

            response.put("badElements", etk.createSQL(Utility.isSqlServer(etk) ? "SELECT /* This query hasn't been tested much but it is SUPPOSED to find the difference between column types in etk and the db. * It only looks at things in etk_data_element. */ elements.DATAOBJECTNAME, elements.DATAELEMENTNAME, elements.ELEMENTTYPE, elements.ELEMENTTYPENAME, elements.DATASIZE, elements.BOUNDTOLOOKUP, elements.ISLOOKUP, elements.COLUMNTABLE, elements.ELEMENTCOLUMN, elements.COLUMNLENGTH, elements.COLUMNTYPE, elements.COLUMNNUMBERPRECISION, elements.COLUMNNUMBERSCALE, elements.COLUMNDATEPRECISION FROM ( SELECT dataObject.name dataObjectName, dataElement.name dataElementName, dataElement.data_type elementType, CASE dataElement.data_type WHEN 1 THEN 'Text' WHEN 2 THEN 'Number' WHEN 3 THEN 'Date' WHEN 4 THEN 'Currency' WHEN 5 THEN 'Yes/No' WHEN 8 THEN 'File' WHEN 9 THEN 'State' WHEN 10 THEN 'Password' WHEN 11 THEN 'Long Text' WHEN 12 THEN 'Timestamp' WHEN 13 THEN 'Plugin Based' ELSE 'UNKNOWN' END elementTypeName, dataElement.column_name elementColumn, dataElement.data_size dataSize, dataElement.bound_to_lookup boundToLookup, CASE dataElement.bound_to_lookup WHEN 1 THEN 'Yes' ELSE 'No' END ISLOOKUP, CASE WHEN ISNULL(dataElement.table_name, '') != '' THEN dataElement.table_name ELSE dataObject.table_name END columnTable, columns.data_type columnType, columns.character_maximum_length columnLength, columns.numeric_precision columnNumberPrecision, columns.datetime_precision columnDatePrecision, columns.numeric_scale columnNumberScale FROM etk_data_object dataObject JOIN etk_data_element dataElement ON dataElement.data_object_id = dataObject.data_object_id JOIN information_schema.columns columns ON columns.column_name = dataElement.column_name AND columns.table_name = CASE WHEN ISNULL(dataElement.table_name, '') != '' THEN dataElement.table_name ELSE dataObject.table_name END WHERE dataObject.tracking_config_id = ( SELECT MAX (tracking_config_id) FROM etk_tracking_config_archive ) ) elements WHERE NOT (((elements.COLUMNTABLE + '.' + elements.ELEMENTCOLUMN) in (:excludedColumns)) OR ( /* TEXT. Note that if the element is a lookup then they set the size to 0 which is why that check is there. Now I have discovered that this may also apply to old non-lookups*/ elements.elementType = 1 AND CASE WHEN elements.boundToLookup = 1 THEN 255 ELSE elements.dataSize END = elements.columnLength AND columnType = 'varchar' ) OR ( /* NUMBER */ elements.elementType = 2 AND elements.columnType = 'int' AND elements.columnNumberPrecision = 10 AND columnNumberScale = 0 ) OR ( /* DATETIME */ elements.elementType = 3 AND elements.columnType = 'datetime' AND columnDatePrecision = 3 ) OR ( /* CURRENCY */ elements.elementType = 4 AND columnType = 'numeric' AND columnNumberPrecision = 18 AND columnNumberScale = 2 ) OR ( /* YESNO */ elements.elementType = 5 AND columnType = 'tinyint' AND columnNumberPrecision = 3 AND columnNumberScale = 0 ) OR ( /* FILE */ elements.elementType = 8 AND columnType = 'numeric' AND columnNumberPrecision = 19 AND columnNumberScale = 0 ) OR ( /* ID_WORKFLOW */ elements.elementType = 9 AND columnType = 'numeric' AND columnNumberPrecision = 19 AND columnNumberScale = 0 ) OR ( /* PASSWORD */ elements.elementType = 10 AND columnType = 'varchar' AND columnLength = 255 AND EXISTS ( SELECT * FROM information_schema.columns columns WHERE columns.table_name = elements.columnTable AND columns.column_name = elements.elementColumn + '_DTS' AND columns.data_type = 'datetime' AND columns.datetime_precision = 3 ) AND EXISTS ( SELECT * FROM information_schema.columns columns WHERE columns.table_name = elements.columnTable AND columns.column_name = elements.elementColumn + '_UID' AND columns.data_type = 'numeric' AND columns.numeric_precision = 19 AND columns.numeric_scale = 0 ) ) OR ( /* LONGTEXT. That magical number is the maximum value of a java int */ elements.elementType = 11 AND columnType = 'text' AND columnLength = '2147483647' ) OR ( /* TIME */ elements.elementType = 12 AND elements.columnType = 'datetime' AND columnDatePrecision = 3 ) OR( /* PLUGIN */ elements.elementType = 13 ) ) ORDER BY dataObjectName, dataElementName"
                    : "SELECT /* This query hasn't been tested much but it is SUPPOSED to find the difference between column types in etk and the db. * It only looks at things in etk_data_element. */ elements.DATAOBJECTNAME, elements.DATAELEMENTNAME, elements.ELEMENTTYPE, elements.ELEMENTTYPENAME, elements.DATASIZE, elements.BOUNDTOLOOKUP, elements.ISLOOKUP, elements.COLUMNTABLE, elements.ELEMENTCOLUMN, elements.COLUMNLENGTH, elements.COLUMNTYPE, elements.COLUMNDATAPRECISION, elements.COLUMNDECLLENGTH, elements.COLUMNCHARLENGTH, elements.COLUMNCHARUSED, elements.COLUMNNUMBERSCALE FROM (SELECT dataObject.name dataObjectName, dataElement.name dataElementName, dataElement.data_type elementType, CASE dataElement.data_type WHEN 1 THEN 'Text' WHEN 2 THEN 'Number' WHEN 3 THEN 'Date' WHEN 4 THEN 'Currency' WHEN 5 THEN 'Yes/No' WHEN 8 THEN 'File' WHEN 9 THEN 'State' WHEN 10 THEN 'Password' WHEN 11 THEN 'Long Text' WHEN 12 THEN 'Timestamp' WHEN 13 THEN 'Plugin Based' ELSE 'UNKNOWN' END elementTypeName, dataElement.column_name elementColumn, dataElement.data_size dataSize, dataElement.bound_to_lookup boundToLookup, CASE dataElement.bound_to_lookup WHEN 1 THEN 'Yes' ELSE 'No' END ISLOOKUP, CASE WHEN dataElement.table_name IS NOT NULL THEN dataElement.table_name ELSE dataObject.table_name END columnTable, columns.data_type columnType, columns.data_length columnLength, columns.data_precision columnDataPrecision, columns. char_col_decl_length columnDeclLength, columns.char_length columnCharLength, columns.char_used columnCharUsed, columns.data_scale columnNumberScale FROM etk_data_object dataObject JOIN etk_data_element dataElement ON dataElement.data_object_id = dataObject.data_object_id JOIN user_tab_cols columns ON columns.column_name = dataElement.column_name AND columns.table_name = CASE WHEN dataElement.table_name IS NOT NULL THEN dataElement.table_name ELSE dataObject.table_name END WHERE dataObject.tracking_config_id = (SELECT MAX (tracking_config_id) FROM etk_tracking_config_archive ) ) elements WHERE NOT (((elements.COLUMNTABLE || '.' || elements.ELEMENTCOLUMN) IN (:excludedColumns)) OR ( /* TEXT. Note that if the element is a lookup then they set the size to 0 which is why that check is there. Now I have discovered that this may also apply to old non-lookups*/ elements.elementType = 1 AND CASE WHEN elements.boundToLookup = 1 THEN 255 ELSE elements.dataSize END = elements.columnCharLength AND columnType = 'VARCHAR2' /* Around 3.21, they switched from B to C */ AND columnCharUsed IN( 'B', 'C') AND columnNumberScale = 0) OR ( /* NUMBER */ elements.elementType = 2 AND elements.columnType = 'NUMBER' AND elements.columnLength = 22 AND elements.columnDataPrecision = 10 AND columnNumberScale = 0) OR ( /* DATETIME */ elements.elementType = 3 AND elements.columnType = 'DATE' AND columnLength = 7 AND columnNumberScale = 0) OR ( /* CURRENCY */ elements.elementType = 4 AND columnType = 'NUMBER' AND columnLength = 22 AND columnDataPrecision = 18 AND columnNumberScale = 2) OR ( /* YESNO */ elements.elementType = 5 AND columnType = 'NUMBER' AND columnLength = 22 AND columnDataPrecision = 1 AND columnNumberScale = 0) OR ( /* FILE */ elements.elementType = 8 AND columnType = 'NUMBER' AND columnLength = 22 AND columnDataPrecision = 19 AND columnNumberScale = 0) OR ( /* ID_WORKFLOW */ elements.elementType = 9 AND columnType = 'NUMBER' AND columnLength = 22 AND columnDataPrecision = 19 AND columnNumberScale = 0) OR ( /* PASSWORD */ elements.elementType = 10 AND columnType = 'VARCHAR2' AND columnLength = 255 AND columnDeclLength = 255 AND columnCharLength = 255 AND columnCharUsed IN('B', 'C') AND EXISTS (SELECT * FROM user_tab_cols columns WHERE columns.table_name = elements.columnTable AND columns.column_name = elements.elementColumn || '_DTS' AND ((columns.data_type = 'DATE' AND columns.data_length = 7) OR (columns.data_type = 'TIMESTAMP(6)' AND columns.data_length = 11 AND columns.data_scale = 6)) ) AND EXISTS (SELECT * FROM user_tab_cols columns WHERE columns.table_name = elements.columnTable AND columns.column_name = elements.elementColumn || '_UID' AND columns.data_type = 'NUMBER' AND columns.data_length = 22 AND columns.data_precision = 19 AND columns.data_scale = 0 ) ) OR ( /* LONGTEXT. For Some reason the columnLength is 4000 */ elements.elementType = 11 AND columnType = 'CLOB' AND columnLength = '4000' AND columnDeclLength = 4000 AND columnCharLength = 0) OR ( /* TIME */ elements.elementType = 12 /* Around 3.21, time fields changed from Date to Timestamp */ AND ((elements.columnType = 'DATE' AND columnLength = 7) OR ( elements.columnType = 'TIMESTAMP(6)' AND elements.columnLength = 11 AND elements.columnNumberScale = 6 ))) OR /* PLUGIN */ elements.elementType = 13 ) ORDER BY dataObjectName, dataElementName")
                    .setParameter("excludedColumns", excludedColumns)
            		.fetchJSON());

            return response;
    }
}
